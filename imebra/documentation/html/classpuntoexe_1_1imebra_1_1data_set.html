<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>imebra: puntoexe::imebra::dataSet Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="style.1.7.5.1.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">imebra
   &#160;<span id="projectnumber">build 2011-09-18_22-24-41</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="pages.html"><span>User&#160;manual</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classpuntoexe_1_1imebra_1_1data_set.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">puntoexe::imebra::dataSet Class Reference<div class="ingroups"><a class="el" href="group__group__dataset.html">Dicom data</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="puntoexe::imebra::dataSet" --><!-- doxytag: inherits="dataCollection&lt; dataGroup &gt;" -->
<p>A data set is a collection of groups of tags (see <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html" title="Represents a Dicom group which stores a group of Dicom tags.">dataGroup</a>).  
 <a href="classpuntoexe_1_1imebra_1_1data_set.html#details">More...</a></p>

<p><code>#include &lt;dataSet.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for puntoexe::imebra::dataSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpuntoexe_1_1imebra_1_1data_set.png" usemap="#puntoexe::imebra::dataSet_map" alt=""/>
  <map id="puntoexe::imebra::dataSet_map" name="puntoexe::imebra::dataSet_map">
<area href="classpuntoexe_1_1imebra_1_1data_collection.html" alt="puntoexe::imebra::dataCollection&lt; dataGroup &gt;" shape="rect" coords="0,56,276,80"/>
<area href="classpuntoexe_1_1base_object.html" title="This is the base class of the library. Almost all the classes in the library are derived from this on..." alt="puntoexe::baseObject" shape="rect" coords="0,0,276,24"/>
</map>
 </div></div>

<p><a href="classpuntoexe_1_1imebra_1_1data_set-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set groups/tags</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data.html">data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a247c06062168d4c942ae31e1ca5428b6">getTag</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, bool bCreate=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag object.  <a href="#a247c06062168d4c942ae31e1ca5428b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a4215cfc29e73d2b0c70588651da9fb7d">getGroup</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, bool bCreate=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a group object.  <a href="#a4215cfc29e73d2b0c70588651da9fb7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a26e7779c68f5f619d898d03db89cb156">setGroup</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt; pGroup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the specified group into the dataset.  <a href="#a26e7779c68f5f619d898d03db89cb156"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set the image</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a9bebb11cb0d0cedbf5547046b77a110c">getImage</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> frameNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an image from the dataset.  <a href="#a9bebb11cb0d0cedbf5547046b77a110c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a472590f3be0e8b743cfb10a0cdbb8fbc">setImage</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> frameNumber, <a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt; pImage, std::wstring transferSyntax, <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1codec.html#a2049bc83bc9c0c3345206bf34d4a3be9">codecs::codec::quality</a> quality)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an image into the data set.  <a href="#a472590f3be0e8b743cfb10a0cdbb8fbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a68d4534accd2dd9baf551c718636876a">getFrameOffset</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> frameNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a frame's offset from the offset table.  <a href="#a68d4534accd2dd9baf551c718636876a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#afed25022cbc574d1a31558eaf631dee9">getFrameBufferId</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> offset, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> *pLengthToBuffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the buffer that starts at the specified offset.  <a href="#afed25022cbc574d1a31558eaf631dee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#abc19a50b288aaf04782abe466b1e5659">getFrameBufferIds</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> frameNumber, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> *pFirstBuffer, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> *pEndBuffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first and the last buffers used to store the image.  <a href="#abc19a50b288aaf04782abe466b1e5659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aef1e6c1c474eeab0d26b64ae042abd1c">getFirstAvailFrameBufferId</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first buffer's id available where a new frame can be saved.  <a href="#aef1e6c1c474eeab0d26b64ae042abd1c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set a sequence item</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html">dataSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#acaae2e50e520fd612f7adda47c7189fb">getSequenceItem</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> itemId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a data set embedded into a sequence tag.  <a href="#acaae2e50e520fd612f7adda47c7189fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1lut.html">lut</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a889bbc1eb9d6239144428b6dca41afe5">getLut</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> lutId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a LUT.  <a href="#a889bbc1eb9d6239144428b6dca41afe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1waveform.html">waveform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a0a94d5157b1f27f783110dc227d767cd">getWaveform</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> waveformId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a waveform from the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a>.  <a href="#a0a94d5157b1f27f783110dc227d767cd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set the tags' values</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga9bfbda01c085f6fa3d53bdeb1017c78f">imbxInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a212fa8cdd50c304452eb769c8283c62f">getSignedLong</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as a signed long.  <a href="#a212fa8cdd50c304452eb769c8283c62f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6644c30ab83b35afe53899e6dbf971e7">setSignedLong</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber, <a class="el" href="group__group__baseclasses.html#ga9bfbda01c085f6fa3d53bdeb1017c78f">imbxInt32</a> newValue, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as a signed long.  <a href="#a6644c30ab83b35afe53899e6dbf971e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6595f6063f45747014e7a74cf31cbec1">getUnsignedLong</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as an unsigned long.  <a href="#a6595f6063f45747014e7a74cf31cbec1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a32444a67dc951e1b5ff6748d93ee69ad">setUnsignedLong</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> newValue, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as an unsigned long.  <a href="#a32444a67dc951e1b5ff6748d93ee69ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a26f3186cc2c979302b83b881838fccce">getDouble</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as a double.  <a href="#a26f3186cc2c979302b83b881838fccce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a17bc7ae816cb4672adfb410f087a3d50">setDouble</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber, double newValue, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as a double.  <a href="#a17bc7ae816cb4672adfb410f087a3d50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa58f5e1d5c66a7183306aed66005c096">getString</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6b28a2b7e1046c19ab0dc754fe30fdff" title="Retrieve a tag&#39;s value as an unicode string.">getUnicodeString()</a> is preferred over this method.  <a href="#aa58f5e1d5c66a7183306aed66005c096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6b28a2b7e1046c19ab0dc754fe30fdff">getUnicodeString</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as an unicode string.  <a href="#a6b28a2b7e1046c19ab0dc754fe30fdff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a0814b1b4d5fb890b28356e9a113b451e">setString</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber, std::string newString, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aacca714c42bb4fe7ba4d6c9ea7991f96" title="Set a tag&#39;s value as an unicode string.">setUnicodeString()</a> is preferred over this method.  <a href="#a0814b1b4d5fb890b28356e9a113b451e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aacca714c42bb4fe7ba4d6c9ea7991f96">setUnicodeString</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> elementNumber, std::wstring newString, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as an unicode string.  <a href="#aacca714c42bb4fe7ba4d6c9ea7991f96"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data handlers</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a0b14ba77bc045bd5667970752bbecb63">getDefaultDataType</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default data type for the specified tag's id.  <a href="#a0b14ba77bc045bd5667970752bbecb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#acbd8b9c2e7bc5869f440d587704122be">getDataType</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data type of a tag.  <a href="#acbd8b9c2e7bc5869f440d587704122be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler.html">handlers::dataHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#af2d699aa4a18e57da05f132064633a5d">getDataHandler</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> bufferId, bool bWrite, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a data handler for the specified tag's buffer.  <a href="#af2d699aa4a18e57da05f132064633a5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler_raw.html">handlers::dataHandlerRaw</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a80c83a6f6e73c48b70f9083ca7b4e9d0">getDataHandlerRaw</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> bufferId, bool bWrite, std::string defaultType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw data handler for the specified tag's buffer.  <a href="#a80c83a6f6e73c48b70f9083ca7b4e9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_reader.html">streamReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a2cac2f4708d242b62ad9f89458e9001d">getStreamReader</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> bufferId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classpuntoexe_1_1stream_reader.html" title="Represents a stream reader. A stream reader can read data from a stream. Several stream readers can s...">streamReader</a> connected to the specified tag's buffer's memory.  <a href="#a2cac2f4708d242b62ad9f89458e9001d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_writer.html">streamWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#abd7cb4c35f7c0c084fbaed3295115f67">getStreamWriter</a> (<a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> groupId, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> order, <a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a> tagId, <a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> bufferId, std::string dataType=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classpuntoexe_1_1stream_writer.html" title="Use this class to write into a baseStream derived class.">streamWriter</a> connected to the specified tag's buffer's memory.  <a href="#abd7cb4c35f7c0c084fbaed3295115f67"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Syncronize the charset tag (0008,0005)</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ae2691c6449b03aa9d7098ae92206cfc6">updateCharsetTag</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all the charsets used in the dataSet's tags and then update the content of the tag 0008,0005.  <a href="#ae2691c6449b03aa9d7098ae92206cfc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a206defbf8d6e74c6de6d628143b847c2">updateTagsCharset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all the dataSet's tags with the charsets specified in the tag 0008,0005.  <a href="#a206defbf8d6e74c6de6d628143b847c2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Set/get the item offset.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#abdca526fdd459ba6a144588a905e2ae2">setItemOffset</a> (<a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1dicom_codec.html" title="The Dicom codec.">codecs::dicomCodec</a> when the dataset is written into a stream. Tells the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> the position at which it has been written into the stream.  <a href="#abdca526fdd459ba6a144588a905e2ae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a4f3a9e6cfbb14f39cc49f212daeabf56">getItemOffset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the offset at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> is located in the dicom stream.  <a href="#a4f3a9e6cfbb14f39cc49f212daeabf56"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A data set is a collection of groups of tags (see <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html" title="Represents a Dicom group which stores a group of Dicom tags.">dataGroup</a>). </p>
<p>The <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> is usually built from a dicom stream by using the codec <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1dicom_codec.html" title="The Dicom codec.">codecs::dicomCodec</a>.</p>
<p>Also the tags with the data type SQ (sequence) contains one or more embedded dataSets that can be retrieved by using <a class="el" href="classpuntoexe_1_1imebra_1_1data.html#a528caafcf662331f994c2a9170c09625" title="Retrieve an embedded data set.">data::getDataSet()</a>.</p>
<p>If your application creates a new dataset then it can set the default dataSet's charset by calling <a class="el" href="classpuntoexe_1_1imebra_1_1data_collection.html#a34e13cd4355bd3a3a0dd142dc9e51c79" title="Set the charsets used in the collection.">setCharsetsList()</a>. See <a class="el" href="imebra_unicode.html">Imebra &amp; Unicode</a> for more information related to Imebra and the Dicom charsets.</p>
<p>The <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> and its components (all the <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html" title="Represents a Dicom group which stores a group of Dicom tags.">dataGroup</a>, and data) share a common lock object: this means that a lock on one of the dataSet's component will lock the entire <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> and all its components.</p>
<p>For an introduction to the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a>, read <a class="el" href="quick_tour.html#quick_tour_dataSet">Let's read a dataSet</a>. </p>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="change_transfer_syntax_2change_transfer_syntax_8cpp-example.html#_a6">changeTransferSyntax/changeTransferSyntax.cpp</a>.</p>
</dd>
</dl></div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af2d699aa4a18e57da05f132064633a5d"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getDataHandler" ref="af2d699aa4a18e57da05f132064633a5d" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 bufferId, bool bWrite, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler.html">handlers::dataHandler</a> &gt; puntoexe::imebra::dataSet::getDataHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>bufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a data handler for the specified tag's buffer. </p>
<p>The data handler allows the application to read, write and resize the tag's buffer.</p>
<p>A tag can store several buffers, then the application must specify the buffer's id it wants to deal with.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
    <tr><td class="paramname">bWrite</td><td>true if the application wants to write into the buffer </td></tr>
    <tr><td class="paramname">defaultType</td><td>a string with the dicom data type to use if the buffer doesn't exist. If none is specified, then a default data type will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the data handler. </dd></dl>

</div>
</div>
<a class="anchor" id="a80c83a6f6e73c48b70f9083ca7b4e9d0"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getDataHandlerRaw" ref="a80c83a6f6e73c48b70f9083ca7b4e9d0" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 bufferId, bool bWrite, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler_raw.html">handlers::dataHandlerRaw</a> &gt; puntoexe::imebra::dataSet::getDataHandlerRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>bufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a raw data handler for the specified tag's buffer. </p>
<p>A raw data handler always sees the buffer as a collection of bytes, no matter what the tag's data type is.</p>
<p>A tag can store several buffers, then the application must specify the buffer's id it wants to deal with.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
    <tr><td class="paramname">bWrite</td><td>true if the application wants to write into the buffer </td></tr>
    <tr><td class="paramname">defaultType</td><td>a string with the dicom data type to use if the buffer doesn't exist. If none is specified, then a default data type will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the data handler. </dd></dl>

</div>
</div>
<a class="anchor" id="acbd8b9c2e7bc5869f440d587704122be"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getDataType" ref="acbd8b9c2e7bc5869f440d587704122be" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string puntoexe::imebra::dataSet::getDataType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the data type of a tag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>When multiple groups with the same it are present, then use this parameter to specify which group must be used. The first group as an order of 0. </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag for which the type must be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string with the tag's type. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b14ba77bc045bd5667970752bbecb63"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getDefaultDataType" ref="a0b14ba77bc045bd5667970752bbecb63" args="(imbxUint16 groupId, imbxUint16 tagId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string puntoexe::imebra::dataSet::getDefaultDataType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the default data type for the specified tag's id. </p>
<p>The default data type is retrieved from an internal dictionary which stores the default properties of each dicom's tag.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag belongs </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the tag's default type. The returned string is a constant. </dd></dl>

</div>
</div>
<a class="anchor" id="a26f3186cc2c979302b83b881838fccce"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getDouble" ref="a26f3186cc2c979302b83b881838fccce" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double puntoexe::imebra::dataSet::getDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a tag's value as a double. </p>
<p>Read the value of the requested tag and return it as a double.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tag's content, as a double </dd></dl>

</div>
</div>
<a class="anchor" id="aef1e6c1c474eeab0d26b64ae042abd1c"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getFirstAvailFrameBufferId" ref="aef1e6c1c474eeab0d26b64ae042abd1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> puntoexe::imebra::dataSet::getFirstAvailFrameBufferId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first buffer's id available where a new frame can be saved. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the id of the first buffer available to store a new frame </dd></dl>

</div>
</div>
<a class="anchor" id="afed25022cbc574d1a31558eaf631dee9"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getFrameBufferId" ref="afed25022cbc574d1a31558eaf631dee9" args="(imbxUint32 offset, imbxUint32 *pLengthToBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> puntoexe::imebra::dataSet::getFrameBufferId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> *&#160;</td>
          <td class="paramname"><em>pLengthToBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the id of the buffer that starts at the specified offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>one offset retrieved from the frames offset table: see <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a68d4534accd2dd9baf551c718636876a" title="Get a frame&#39;s offset from the offset table.">getFrameOffset()</a> </td></tr>
    <tr><td class="paramname">pLengthToBuffer</td><td>a pointer to a variable that will store the total lenght of the buffers that preceed the one being returned (doesn't include the tag descriptors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the id of the buffer that starts at the specified offset </dd></dl>

</div>
</div>
<a class="anchor" id="abc19a50b288aaf04782abe466b1e5659"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getFrameBufferIds" ref="abc19a50b288aaf04782abe466b1e5659" args="(imbxUint32 frameNumber, imbxUint32 *pFirstBuffer, imbxUint32 *pEndBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> puntoexe::imebra::dataSet::getFrameBufferIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>frameNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> *&#160;</td>
          <td class="paramname"><em>pFirstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> *&#160;</td>
          <td class="paramname"><em>pEndBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the first and the last buffers used to store the image. </p>
<p>This function works only with the new Dicom3 streams, not with the old NEMA format.</p>
<p>This function is used by <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a472590f3be0e8b743cfb10a0cdbb8fbc" title="Insert an image into the data set.">setImage()</a> and <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a9bebb11cb0d0cedbf5547046b77a110c" title="Retrieve an image from the dataset.">getImage()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>the frame for which the buffers have to be retrieved </td></tr>
    <tr><td class="paramname">pFirstBuffer</td><td>a pointer to a variable that will contain the id of the first buffer used to store the image </td></tr>
    <tr><td class="paramname">pEndBuffer</td><td>a pointer to a variable that will contain the id of the first buffer next to the last one used to store the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total length of the buffers that contain the image </dd></dl>

</div>
</div>
<a class="anchor" id="a68d4534accd2dd9baf551c718636876a"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getFrameOffset" ref="a68d4534accd2dd9baf551c718636876a" args="(imbxUint32 frameNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> puntoexe::imebra::dataSet::getFrameOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>frameNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a frame's offset from the offset table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>the number of the frame for which the offset is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the offset for the specified frame </dd></dl>

</div>
</div>
<a class="anchor" id="a4215cfc29e73d2b0c70588651da9fb7d"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getGroup" ref="a4215cfc29e73d2b0c70588651da9fb7d" args="(imbxUint16 groupId, imbxUint16 order, bool bCreate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt; puntoexe::imebra::dataSet::getGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a group object. </p>
<p>A Group object is represented by the <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> class.</p>
<p>If the group doesn't exist and the parameter bCreate is set to false, then the function returns a null pointer. If the group doesn't exist and the parameter bCreate is set to true, then an empty group will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to retrieve. </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify which group must be retrieved. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero. </td></tr>
    <tr><td class="paramname">bCreate</td><td>When bCreate is set to true and the requested group doesn't exist, then a new one is created and inserted into the dataset. When bCreate is set to false and the requested group doesn't exist, then a null pointer is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the retrieved group. The group should be released as soon as possible using the function Release(). If the requested group doesn't exist then the returned value depend on the value of the bCreate parameter: when bCreate is false then a value of zero is returned, otherwise a pointer to the just created group is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bebb11cb0d0cedbf5547046b77a110c"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getImage" ref="a9bebb11cb0d0cedbf5547046b77a110c" args="(imbxUint32 frameNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt; puntoexe::imebra::dataSet::getImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>frameNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an image from the dataset. </p>
<p>The right codec will be automatically used to decode the image embedded into the dataset. If multiple frames are available, then the calling application can decide the frame to retrieve.</p>
<p>The function throw an exception if the requested image doesn't exist or the image's tag is corrupted.</p>
<p>The retrieved image should then be processed by the <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1modality_v_o_i_l_u_t.html" title="This class transforms the pixel values of the image retrieved from the dataset into values that are m...">transforms::modalityVOILUT</a> transform in order to convert the pixels value to a meaningful space. Infact, the dicom image's pixel values saved by other application have a meaningful value only for the application that generated them, while the modality VOI/LUT transformation will convert those values to a more portable unit (e.g.: optical density).</p>
<p>Further transformations are applied by the <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html" title="Transform the value of the input image&#39;s pixels by using the presentation VOI/LUT defined in the data...">transforms::VOILUT</a> transform, in order to adjust the image's contrast for displaying purposes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>The frame number to retrieve. The first frame's id is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the retrieved image </dd></dl>

</div>
</div>
<a class="anchor" id="a4f3a9e6cfbb14f39cc49f212daeabf56"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getItemOffset" ref="a4f3a9e6cfbb14f39cc49f212daeabf56" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> puntoexe::imebra::dataSet::getItemOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the offset at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> is located in the dicom stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the position at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> is located in the dicom stream </dd></dl>

</div>
</div>
<a class="anchor" id="a889bbc1eb9d6239144428b6dca41afe5"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getLut" ref="a889bbc1eb9d6239144428b6dca41afe5" args="(imbxUint16 groupId, imbxUint16 tagId, imbxUint32 lutId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1lut.html">lut</a> &gt; puntoexe::imebra::dataSet::getLut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>lutId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a LUT. </p>
<p>LUT are encoded into sequences. This function retrieve the sequence and build a <a class="el" href="classpuntoexe_1_1imebra_1_1lut.html">lut</a> object describing the LUT.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the LUT sequence belongs </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to containing the LUT </td></tr>
    <tr><td class="paramname">lutId</td><td>The id of the lut inside the tag (0 based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the retrieved LUT. If the requested group, tag or buffer (sequence item) doesn't exist, or if the tag's type is not a sequence (SQ), then a null pointer is returned, otherwise a pointer to the retrieved LUT is returned </dd></dl>

</div>
</div>
<a class="anchor" id="acaae2e50e520fd612f7adda47c7189fb"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getSequenceItem" ref="acaae2e50e520fd612f7adda47c7189fb" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 itemId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html">dataSet</a> &gt; puntoexe::imebra::dataSet::getSequenceItem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>itemId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a data set embedded into a sequence tag. </p>
<p>Sequence tags store several binary data which can be individually parsed as a normal dicom file (without the preamble of 128 bytes and the DICM signature).</p>
<p>Using sequences, an application can store several nested dicom structures.</p>
<p>This function parse a single item of a sequence tag and return a data set object (represented by a this class) which stores the retrieved tags.</p>
<p>If the requested tag's type is not a sequence or the requested item in the sequence is missed, then a null pointer will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the sequence tag to be parsed belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify which group must be retrieved. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to parse </td></tr>
    <tr><td class="paramname">itemId</td><td>The id of the tag's item to parse (zero based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the retrieved data set. If the requested group, tag or buffer (sequence item) doesn't exist, or if the tag's type is not a sequence (SQ), then a null pointer is returned, otherwise a pointer to the retrieved dataset is returned </dd></dl>

</div>
</div>
<a class="anchor" id="a212fa8cdd50c304452eb769c8283c62f"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getSignedLong" ref="a212fa8cdd50c304452eb769c8283c62f" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga9bfbda01c085f6fa3d53bdeb1017c78f">imbxInt32</a> puntoexe::imebra::dataSet::getSignedLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a tag's value as a signed long. </p>
<p>Read the value of the requested tag and return it as a signed long.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tag's content, as a signed long </dd></dl>

</div>
</div>
<a class="anchor" id="a2cac2f4708d242b62ad9f89458e9001d"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getStreamReader" ref="a2cac2f4708d242b62ad9f89458e9001d" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 bufferId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_reader.html">streamReader</a> &gt; puntoexe::imebra::dataSet::getStreamReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>bufferId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classpuntoexe_1_1stream_reader.html" title="Represents a stream reader. A stream reader can read data from a stream. Several stream readers can s...">streamReader</a> connected to the specified tag's buffer's memory. </p>
<p>A tag can store several buffers: the application must specify the buffer's id it wants to deal with.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the <a class="el" href="classpuntoexe_1_1stream_reader.html" title="Represents a stream reader. A stream reader can read data from a stream. Several stream readers can s...">streamReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd7cb4c35f7c0c084fbaed3295115f67"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getStreamWriter" ref="abd7cb4c35f7c0c084fbaed3295115f67" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 bufferId, std::string dataType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_writer.html">streamWriter</a> &gt; puntoexe::imebra::dataSet::getStreamWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>bufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dataType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classpuntoexe_1_1stream_writer.html" title="Use this class to write into a baseStream derived class.">streamWriter</a> connected to the specified tag's buffer's memory. </p>
<p>A tag can store several buffers, then the application must specify the buffer's id it wants to deal with.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
    <tr><td class="paramname">dataType</td><td>the datatype used to create the buffer if it doesn't exist already </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the <a class="el" href="classpuntoexe_1_1stream_writer.html" title="Use this class to write into a baseStream derived class.">streamWriter</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa58f5e1d5c66a7183306aed66005c096"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getString" ref="aa58f5e1d5c66a7183306aed66005c096" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string puntoexe::imebra::dataSet::getString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6b28a2b7e1046c19ab0dc754fe30fdff" title="Retrieve a tag&#39;s value as an unicode string.">getUnicodeString()</a> is preferred over this method. </p>
<p>Read the value of the requested tag and return it as a string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tag's content, as a string </dd></dl>

</div>
</div>
<a class="anchor" id="a247c06062168d4c942ae31e1ca5428b6"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getTag" ref="a247c06062168d4c942ae31e1ca5428b6" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, bool bCreate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data.html">data</a> &gt; puntoexe::imebra::dataSet::getTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a tag object. </p>
<p>Tag object is represented by the <a class="el" href="classpuntoexe_1_1imebra_1_1data.html">data</a> class.</p>
<p>If the tag doesn't exist and the parameter bCreate is set to false, then the function returns a null pointer. If the tag doesn't exist and the parameter bCreate is set to true, then an empty tag will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag belongs. </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify which group must be retrieved. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero. </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve. </td></tr>
    <tr><td class="paramname">bCreate</td><td>When bCreate is set to true and the requested tag doesn't exist, then a new one is created and inserted into the dataset. When bCreate is set to false and the requested tag doesn't exist, then a null pointer is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the retrieved tag. If the requested tag doesn't exist then the returned value depend on the value of the bCreate parameter: when bCreate is false then a value of zero is returned, otherwise a pointer to the just created tag is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b28a2b7e1046c19ab0dc754fe30fdff"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getUnicodeString" ref="a6b28a2b7e1046c19ab0dc754fe30fdff" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring puntoexe::imebra::dataSet::getUnicodeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a tag's value as an unicode string. </p>
<p>Read the value of the requested tag and return it as an unicode string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tag's content, as an unicode string </dd></dl>

</div>
</div>
<a class="anchor" id="a6595f6063f45747014e7a74cf31cbec1"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getUnsignedLong" ref="a6595f6063f45747014e7a74cf31cbec1" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a> puntoexe::imebra::dataSet::getUnsignedLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a tag's value as an unsigned long. </p>
<p>Read the value of the requested tag and return it as an unsigned long.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tag's content, as an unsigned long </dd></dl>

</div>
</div>
<a class="anchor" id="a0a94d5157b1f27f783110dc227d767cd"></a><!-- doxytag: member="puntoexe::imebra::dataSet::getWaveform" ref="a0a94d5157b1f27f783110dc227d767cd" args="(imbxUint32 waveformId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1waveform.html">waveform</a> &gt; puntoexe::imebra::dataSet::getWaveform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>waveformId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a waveform from the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a>. </p>
<p>Each waveforms is stored in a sequence item; the function retrieves the proper sequence item and connects it to the class waveform which can be used to retrieve the waveform data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">waveformId</td><td>the zero based index of the waveform to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an object waveform that can be used to read the waveform data, or a null pointer if the requested waveform doesn't exist </dd></dl>

</div>
</div>
<a class="anchor" id="a17bc7ae816cb4672adfb410f087a3d50"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setDouble" ref="a17bc7ae816cb4672adfb410f087a3d50" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber, double newValue, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a tag's value as a double. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newValue</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26e7779c68f5f619d898d03db89cb156"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setGroup" ref="a26e7779c68f5f619d898d03db89cb156" args="(imbxUint16 groupId, imbxUint16 order, ptr&lt; dataGroup &gt; pGroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt;&#160;</td>
          <td class="paramname"><em>pGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert the specified group into the dataset. </p>
<p>A Group object is represented by the <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> class.</p>
<p>If a group with the same id and order is already present into the data set, then it is removed to leave space to the new group.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The id of the group to insert into the data set. </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero. </td></tr>
    <tr><td class="paramname">pGroup</td><td>A pointer to the group to insert into the data set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a472590f3be0e8b743cfb10a0cdbb8fbc"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setImage" ref="a472590f3be0e8b743cfb10a0cdbb8fbc" args="(imbxUint32 frameNumber, ptr&lt; image &gt; pImage, std::wstring transferSyntax, codecs::codec::quality quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>frameNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt;&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>transferSyntax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1codec.html#a2049bc83bc9c0c3345206bf34d4a3be9">codecs::codec::quality</a>&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert an image into the data set. </p>
<p>The specified transfer syntax will be used to choose the right codec for the image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>The frame number where the image must be stored. The first frame's id is 0. </td></tr>
    <tr><td class="paramname">pImage</td><td>A pointer to the image object to be stored into the data set. </td></tr>
    <tr><td class="paramname">transferSyntax</td><td>the transfer syntax that specifies the codec and the parameters to use for the encoding </td></tr>
    <tr><td class="paramname">quality</td><td>an enumeration that set the compression quality </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdca526fdd459ba6a144588a905e2ae2"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setItemOffset" ref="abdca526fdd459ba6a144588a905e2ae2" args="(imbxUint32 offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setItemOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1dicom_codec.html" title="The Dicom codec.">codecs::dicomCodec</a> when the dataset is written into a stream. Tells the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> the position at which it has been written into the stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the position at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup).">dataSet</a> has been written into the stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6644c30ab83b35afe53899e6dbf971e7"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setSignedLong" ref="a6644c30ab83b35afe53899e6dbf971e7" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber, imbxInt32 newValue, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setSignedLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga9bfbda01c085f6fa3d53bdeb1017c78f">imbxInt32</a>&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a tag's value as a signed long. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newValue</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0814b1b4d5fb890b28356e9a113b451e"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setString" ref="a0814b1b4d5fb890b28356e9a113b451e" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber, std::string newString, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aacca714c42bb4fe7ba4d6c9ea7991f96" title="Set a tag&#39;s value as an unicode string.">setUnicodeString()</a> is preferred over this method. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newString</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacca714c42bb4fe7ba4d6c9ea7991f96"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setUnicodeString" ref="aacca714c42bb4fe7ba4d6c9ea7991f96" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber, std::wstring newString, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setUnicodeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a tag's value as an unicode string. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newString</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32444a67dc951e1b5ff6748d93ee69ad"></a><!-- doxytag: member="puntoexe::imebra::dataSet::setUnsignedLong" ref="a32444a67dc951e1b5ff6748d93ee69ad" args="(imbxUint16 groupId, imbxUint16 order, imbxUint16 tagId, imbxUint32 elementNumber, imbxUint32 newValue, std::string defaultType=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setUnsignedLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga43ddf23e4eb4a764a81b0a963c05e75a">imbxUint16</a>&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__baseclasses.html#ga4bbb2212fd3d6d4eed1fdf7255b3081d">imbxUint32</a>&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a tag's value as an unsigned long. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newValue</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2691c6449b03aa9d7098ae92206cfc6"></a><!-- doxytag: member="puntoexe::imebra::dataSet::updateCharsetTag" ref="ae2691c6449b03aa9d7098ae92206cfc6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::updateCharsetTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collect all the charsets used in the dataSet's tags and then update the content of the tag 0008,0005. </p>
<p>This function is called by the codecs before the dicom stream is saved, therefore the application doesn't need to call the function before saving the stream. </p>

</div>
</div>
<a class="anchor" id="a206defbf8d6e74c6de6d628143b847c2"></a><!-- doxytag: member="puntoexe::imebra::dataSet::updateTagsCharset" ref="a206defbf8d6e74c6de6d628143b847c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::updateTagsCharset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update all the dataSet's tags with the charsets specified in the tag 0008,0005. </p>
<p>This function is called by the codecs after the stream has been loaded, therefore the application doesn't need to call the function after the stream has been loaded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="data_set_8h.html">dataSet.h</a></li>
<li><a class="el" href="data_set_8cpp.html">dataSet.cpp</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacepuntoexe.html">puntoexe</a>      </li>
      <li class="navelem"><b>imebra</b>      </li>
      <li class="navelem"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html">dataSet</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">
    <a href="http://imebra.com">Imebra.com</a></li>
   </ul>
 </div>


</body>
</html>
