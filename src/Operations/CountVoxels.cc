//CountVoxels.cc - A part of DICOMautomaton 2019. Written by hal clark.

#include <asio.hpp>
#include <algorithm>
#include <optional>
#include <fstream>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <mutex>
#include <regex>
#include <set> 
#include <stdexcept>
#include <string>    
#include <utility>            //Needed for std::pair.
#include <vector>

#include "YgorImages.h"
#include "YgorMath.h"         //Needed for vec3 class.
#include "YgorMisc.h"         //Needed for FUNCINFO, FUNCWARN, FUNCERR macros.
#include "YgorStats.h"        //Needed for Stats:: namespace.
#include "YgorString.h"       //Needed for GetFirstRegex(...)
#include "YgorFilesDirs.h"

#include "Explicator.h"       //Needed for Explicator class.

#include "../Structs.h"
#include "../Regex_Selectors.h"
#include "../Thread_Pool.h"
#include "../Write_File.h"
#include "../YgorImages_Functors/Grouping/Misc_Functors.h"
#include "../YgorImages_Functors/Processing/Partitioned_Image_Voxel_Visitor_Mutator.h"

#include "CountVoxels.h"


OperationDoc OpArgDocCountVoxels(){
    OperationDoc out;
    out.name = "CountVoxels";

    out.desc = 
        "This operation counts the number of voxels confined to one or more ROIs within a user-provided range.";
        
    out.notes.emplace_back(
        "This operation is read-only."
    );
        

    out.args.emplace_back();
    out.args.back() = IAWhitelistOpArgDoc();
    out.args.back().name = "ImageSelection";
    out.args.back().default_val = "last";


    out.args.emplace_back();
    out.args.back() = NCWhitelistOpArgDoc();
    out.args.back().name = "NormalizedROILabelRegex";
    out.args.back().default_val = ".*";

    out.args.emplace_back();
    out.args.back() = RCWhitelistOpArgDoc();
    out.args.back().name = "ROILabelRegex";
    out.args.back().default_val = ".*";

    out.args.emplace_back();
    out.args.back().name = "Inclusivity";
    out.args.back().desc = "Controls how voxels are deemed to be 'within' the interior of the selected ROI(s)."
                           " The default 'center' considers only the central-most point of each voxel."
                           " There are two corner options that correspond to a 2D projection of the voxel onto the image plane."
                           " The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior."
                           " The second, 'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.";
    out.args.back().default_val = "center";
    out.args.back().expected = true;
    out.args.back().examples = { "center", "centre", 
                                 "planar_corner_inclusive", "planar_inc",
                                 "planar_corner_exclusive", "planar_exc" };
    out.args.back().samples = OpArgSamples::Exhaustive;

    out.args.emplace_back();
    out.args.back().name = "ContourOverlap";
    out.args.back().desc = "Controls overlapping contours are treated."
                           " The default 'ignore' treats overlapping contours as a single contour, regardless of"
                           " contour orientation. The option 'honour_opposite_orientations' makes overlapping contours"
                           " with opposite orientation cancel. Otherwise, orientation is ignored. The latter is useful"
                           " for Boolean structures where contour orientation is significant for interior contours (holes)."
                           " The option 'overlapping_contours_cancel' ignores orientation and cancels all contour overlap.";
    out.args.back().default_val = "ignore";
    out.args.back().expected = true;
    out.args.back().examples = { "ignore", "honour_opposite_orientations", 
                                 "overlapping_contours_cancel", "honour_opps", "overlap_cancel" }; 
    out.args.back().samples = OpArgSamples::Exhaustive;


    out.args.emplace_back();
    out.args.back().name = "Lower";
    out.args.back().desc = "The lower bound (inclusive). Pixels with values < this number are excluded from the ROI."
                      " If the number is followed by a '%', the bound will be scaled between the min and max"
                      " pixel values [0-100%]. If the number is followed by 'tile', the bound will be replaced"
                      " with the corresponding percentile [0-100tile]."
                      " Note that upper and lower bounds can be specified separately (e.g., lower bound is a"
                      " percentage, but upper bound is a percentile).";
    out.args.back().default_val = "-inf";
    out.args.back().expected = true;
    out.args.back().examples = { "0.0", "-1E-99", "1.23", "0.2%", "23tile", "23.123 tile" };


    out.args.emplace_back();
    out.args.back().name = "Upper";
    out.args.back().desc = "The upper bound (inclusive). Pixels with values > this number are excluded from the ROI."
                      " If the number is followed by a '%', the bound will be scaled between the min and max"
                      " pixel values [0-100%]. If the number is followed by 'tile', the bound will be replaced"
                      " with the corresponding percentile [0-100tile]."
                      " Note that upper and lower bounds can be specified separately (e.g., lower bound is a"
                      " percentage, but upper bound is a percentile).";
    out.args.back().default_val = "inf";
    out.args.back().expected = true;
    out.args.back().examples = { "1.0", "1E-99", "2.34", "98.12%", "94tile", "94.123 tile" };


    out.args.emplace_back();
    out.args.back().name = "Channel";
    out.args.back().desc = "The image channel to use. Zero-based.";
    out.args.back().default_val = "0";
    out.args.back().expected = true;
    out.args.back().examples = { "0", "1", "2" };


    out.args.emplace_back();
    out.args.back().name = "ResultsSummaryFileName";
    out.args.back().desc = "This file will contain a brief summary of the results."
                      " The format is CSV. Leave empty to dump to generate a unique temporary file."
                      " If an existing file is present, rows will be appended without writing a header.";
    out.args.back().default_val = "";
    out.args.back().expected = true;
    out.args.back().examples = { "", "/tmp/somefile", "localfile.csv", "derivative_data.csv" };
    out.args.back().mimetype = "text/csv";


    out.args.emplace_back();
    out.args.back().name = "UserComment";
    out.args.back().desc = "A string that will be inserted into the output file which will simplify merging output"
                      " with differing parameters, from different sources, or using sub-selections of the data.";
    out.args.back().default_val = "";
    out.args.back().expected = true;
    out.args.back().examples = { "", "Using XYZ", "Patient treatment plan C" };


    return out;
}

Drover CountVoxels(Drover DICOM_data,
                   const OperationArgPkg& OptArgs,
                   const std::map<std::string, std::string>&
                   /*InvocationMetadata*/,
                   const std::string& /*FilenameLex*/){

    //---------------------------------------------- User Parameters --------------------------------------------------
    const auto ImageSelectionStr = OptArgs.getValueStr("ImageSelection").value();

    const auto NormalizedROILabelRegex = OptArgs.getValueStr("NormalizedROILabelRegex").value();
    const auto ROILabelRegex = OptArgs.getValueStr("ROILabelRegex").value();
    const auto InclusivityStr = OptArgs.getValueStr("Inclusivity").value();
    const auto ContourOverlapStr = OptArgs.getValueStr("ContourOverlap").value();

    const auto LowerStr = OptArgs.getValueStr("Lower").value();
    const auto UpperStr = OptArgs.getValueStr("Upper").value();
    const auto ChannelStr = OptArgs.getValueStr("Channel").value();

    auto ResultsSummaryFileName = OptArgs.getValueStr("ResultsSummaryFileName").value();
    const auto UserComment = OptArgs.getValueStr("UserComment");

    //-----------------------------------------------------------------------------------------------------------------
    const auto Lower = std::stod( LowerStr );
    const auto Upper = std::stod( UpperStr );
    const auto Channel = std::stol( ChannelStr );

    const auto regex_is_percent = Compile_Regex(".*[%].*");
    const auto Lower_is_Percent = std::regex_match(LowerStr, regex_is_percent);
    const auto Upper_is_Percent = std::regex_match(UpperStr, regex_is_percent);

    const auto regex_is_tile = Compile_Regex(".*p?e?r?c?e?n?tile.*");
    const auto Lower_is_Ptile = std::regex_match(LowerStr, regex_is_tile);
    const auto Upper_is_Ptile = std::regex_match(UpperStr, regex_is_tile);

    const auto regex_centre = Compile_Regex("^cent.*");
    const auto regex_pci = Compile_Regex("^planar_?c?o?r?n?e?r?s?_?inc?l?u?s?i?v?e?$");
    const auto regex_pce = Compile_Regex("^planar_?c?o?r?n?e?r?s?_?exc?l?u?s?i?v?e?$");

    const auto regex_ignore = Compile_Regex("^ig?n?o?r?e?$");
    const auto regex_honopps = Compile_Regex("^ho?n?o?u?r?_?o?p?p?o?s?i?t?e?_?o?r?i?e?n?t?a?t?i?o?n?s?$");
    const auto regex_cancel = Compile_Regex("^ov?e?r?l?a?p?p?i?n?g?_?c?o?n?t?o?u?r?s?_?c?a?n?c?e?l?s?$");


    //Stuff references to all contours into a list. Remember that you can still address specific contours through
    // the original holding containers (which are not modified here).
    auto cc_all = All_CCs( DICOM_data );
    auto cc_ROIs = Whitelist( cc_all, { { "ROIName", ROILabelRegex },
                                        { "NormalizedROIName", NormalizedROILabelRegex } } );
    if(cc_ROIs.empty()){
        throw std::invalid_argument("No contours selected. Cannot continue.");
    }

    std::mutex locker;
    long int count_inside = 0;
    long int count_outside = 0;
    long int count_nan = 0;
    std::optional<std::string> PatientID;

    auto IAs_all = All_IAs( DICOM_data );
    auto IAs = Whitelist( IAs_all, ImageSelectionStr );
    for(auto & iap_it : IAs){
        if((*iap_it)->imagecoll.images.empty()) continue;

        //Determine the bounds in terms of pixel-value thresholds.
        auto cl = Lower; // Will be replaced if percentages/percentiles requested.
        auto cu = Upper; // Will be replaced if percentages/percentiles requested.
        {
            //Percentage-based.
            if(Lower_is_Percent || Upper_is_Percent){
                Stats::Running_MinMax<float> rmm;
                for(const auto &animg : (*iap_it)->imagecoll.images){
                    animg.apply_to_pixels([&rmm,Channel](long int, long int, long int chnl, float val) -> void {
                         if((Channel < 0) || (Channel == chnl)) rmm.Digest(val);
                         return;
                    });
                }
                if(Lower_is_Percent) cl = (rmm.Current_Min() + (rmm.Current_Max() - rmm.Current_Min()) * Lower / 100.0);
                if(Upper_is_Percent) cu = (rmm.Current_Min() + (rmm.Current_Max() - rmm.Current_Min()) * Upper / 100.0);
            }

            //Percentile-based.
            if(Lower_is_Ptile || Upper_is_Ptile){
                std::vector<float> pixel_vals;
                //pixel_vals.reserve(animg.rows * animg.columns * animg.channels * img_count);
                for(const auto &animg : (*iap_it)->imagecoll.images){
                    animg.apply_to_pixels([&pixel_vals,Channel](long int, long int, long int chnl, float val) -> void {
                         if((Channel < 0) || (Channel == chnl)) pixel_vals.push_back(val);
                         return;
                    });
                }
                if(Lower_is_Ptile) cl = Stats::Percentile(pixel_vals, Lower / 100.0);
                if(Upper_is_Ptile) cu = Stats::Percentile(pixel_vals, Upper / 100.0);
            }
        }
        if(cl > cu){
            throw std::invalid_argument("Thresholds conflict. Mesh will contain zero faces. Refusing to continue.");
        }

        //Construct a pixel 'oracle' closure using the user-specified threshold criteria. This function identifies whether
        //the pixel is within (true) or outside of (false) the final ROI.
        auto pixel_oracle = [cu,cl](float p) -> bool {
            return (cl <= p) && (p <= cu);
        };

        // Look for a patient ID if none has been identified yet.
        if(!PatientID){
            planar_image<float, double> *animg = &( (*iap_it)->imagecoll.images.front() );
            auto l_PatientID = animg->GetMetadataValueAs<std::string>("PatientID"); //.value_or("Unknown");

            std::lock_guard<std::mutex> lock(locker);
            if(l_PatientID) PatientID = l_PatientID;
        }

        PartitionedImageVoxelVisitorMutatorUserData ud;
        ud.mutation_opts.editstyle = Mutate_Voxels_Opts::EditStyle::InPlace;
        ud.mutation_opts.aggregate = Mutate_Voxels_Opts::Aggregate::First;
        ud.mutation_opts.adjacency = Mutate_Voxels_Opts::Adjacency::SingleVoxel;
        ud.mutation_opts.maskmod   = Mutate_Voxels_Opts::MaskMod::Noop;
        //ud.description = "";

        if( std::regex_match(ContourOverlapStr, regex_ignore) ){
            ud.mutation_opts.contouroverlap = Mutate_Voxels_Opts::ContourOverlap::Ignore;
        }else if( std::regex_match(ContourOverlapStr, regex_honopps) ){
            ud.mutation_opts.contouroverlap = Mutate_Voxels_Opts::ContourOverlap::HonourOppositeOrientations;
        }else if( std::regex_match(ContourOverlapStr, regex_cancel) ){
            ud.mutation_opts.contouroverlap = Mutate_Voxels_Opts::ContourOverlap::ImplicitOrientations;
        }else{
            throw std::invalid_argument("ContourOverlap argument '"_s + ContourOverlapStr + "' is not valid");
        }
        if( std::regex_match(InclusivityStr, regex_centre) ){
            ud.mutation_opts.inclusivity = Mutate_Voxels_Opts::Inclusivity::Centre;
        }else if( std::regex_match(InclusivityStr, regex_pci) ){
            ud.mutation_opts.inclusivity = Mutate_Voxels_Opts::Inclusivity::Inclusive;
        }else if( std::regex_match(InclusivityStr, regex_pce) ){
            ud.mutation_opts.inclusivity = Mutate_Voxels_Opts::Inclusivity::Exclusive;
        }else{
            throw std::invalid_argument("Inclusivity argument '"_s + InclusivityStr + "' is not valid");
        }

        ud.f_bounded = [&](long int, long int, long int chan,
                           std::reference_wrapper<planar_image<float,double>>,
                           std::reference_wrapper<planar_image<float,double>>,
                           float &val) {
            if( (Channel < 0) || (Channel == chan) ){
                std::lock_guard<std::mutex> lock(locker);
                if(!std::isfinite(val)){
                    ++count_nan;
                }else if(pixel_oracle(val)){
                    ++count_inside;
                }else{
                    ++count_outside;
                }
            }
            return;
        };

        if(!(*iap_it)->imagecoll.Process_Images_Parallel( GroupIndividualImages,
                                                          PartitionedImageVoxelVisitorMutator,
                                                          {}, cc_ROIs, &ud )){
            throw std::runtime_error("Unable to count voxels.");
        }
    }

    //Report a summary.
    FUNCINFO("Attempting to claim a mutex");
    try{
        auto gen_filename = [&]() -> std::string {
            if(ResultsSummaryFileName.empty()){
                ResultsSummaryFileName = Get_Unique_Sequential_Filename("/tmp/dicomautomaton_countvoxels_", 6, ".csv");
            }
            return ResultsSummaryFileName;
        };

        std::stringstream header;
        header << "Patient ID,"
               << "Voxels within range (abs),"
               << "Voxels within range (rel),"
               << "Voxels outside of range (abs),"
               << "Voxels outside of range (rel),"
               << "NaN voxels (abs),"
               << "NaN voxels (rel),"
               << "Total number of voxels considered,"
               << "User comment"
               << std::endl;

        const auto count_all = count_inside + count_outside + count_nan;

        std::stringstream body;
        body << PatientID.value_or("Unknown") << ","
             << count_inside << ","
             << (100.0 * static_cast<double>(count_inside) / static_cast<double>(count_all)) << "%,"

             << count_outside << ","
             << (100.0 * static_cast<double>(count_outside) / static_cast<double>(count_all)) << "%,"

             << count_nan << ","
             << (100.0 * static_cast<double>(count_nan) / static_cast<double>(count_all)) << "%,"

             << count_all << ","
             << UserComment.value_or("")
             << std::endl;

        Append_File( gen_filename,
                     "dicomautomaton_operation_countvoxels_mutex",
                     header.str(),
                     body.str() );

        FUNCINFO("Writing file containing:" << std::endl << header.str() << std::endl << body.str() << std::endl);

    }catch(const std::exception &e){
        FUNCERR("Unable to write to output file: '" << e.what() << "'");
    }

    return DICOM_data;
}

